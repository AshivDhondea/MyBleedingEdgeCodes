% PjMolniya04GNF.m performs Gauss-Newton filtering on the sensor data
% generated by PjMolniya02SensorData.m

%% Dependencies

% Calls fnGlobePlot.m, fnRK4vector.m and fnKepler3Augmented.m

% Requires data 'SensorMeasurements.mat' which is produced by
% PjMolniya02SensorData.m 

% Requires data 'NominalTrajectory.mat' which is produced by
% PjMolniya03NominalTrajectory.m

% Saves data in 'FilterEstimates.mat' for processing by the subsequent
% project files.

%% Author
% Ashiv Dhondea, RRSG, UCT.
% Date: 11 October 2015
% Edited: 15 October 2015 to adapt to 3 dimenstional problem (i.e. 6 state
% variables)

%% References

% 1. Tracking Filter Engineering. Norman Morrison
% 2. Statistical Orbit Determination. Tapley, Schutz, Born.

%% Clear memory
clear
clc
close all;

%% Declare constants
mu = 398600;     % Earthâ€™s gravitational parameter [km^3/s^2]
R_earth = 6378;  % Earth radius [km]

%% Declare variables
% Load nominal trajectory and state transition matrix generated by PjMolniya03NominalTrajectory.m
load('NominalTrajectory.mat') % Contains Xnom
load('ActualEphemeris.mat') % Contains timevector t and Xactual
load('SensorMeasurements.mat') % Contains sensor output signal and StandardDeviations of noise

%% Reference trajectory and perturbation vector

% perturbation vector X is the deviation from the nominal trajectory.
perturbationVectorX = zeros(6,numel(t)); % 

% Initial Conditions for the IVP
perturbationVectorX(:,1) = deltaX0; % Need to figure out how to initialize the perturbation vector later
 
% Array of Phi matrices
PhiT = zeros(6*size(Xnom,1),6); % state transition matrices

% Initially will be Identity matrix.
PhiT(1:6,1:6) = eye(6); 

for index = 2:size(Xnom,2)  
    % Propagate the perturbation vector through the simulation period.
    
    Phi = reshape(Xnom(end-6*6 + 1:end,index),6,6);% extract Phi matrix
    
    % This Phi matrix is the state transition matrix which propagates the
    % state vector X from tn to tn+ zeta. Since we fixed tn = 0 in this
    % case, we are calculating Phi in 
    % X(zeta) = Phi(zeta)X(0)
    
    perturbationVectorX(:,index) = Phi*perturbationVectorX(:,1); % eqn 2.6.29 in TFE
    
    % Load state transition matrix into the array of STMs
    PhiT(6*index-5:6*index,1:6) = Phi;
end

%% Explanation of System Modeling
% We adopt the methodology employed in the book "Tracking Filter 
% Engineering".

% In the section above, we investigated the dynamic modeling of the system.
% This corresponds to Chapter 2 in TFE.

% Due to the highly nonlinear dynamics ( as evidenced by the fundamental
% matrix F in fnKepler3.m), we do not have an analytical expression for the
% State Transition Matrix (STM), denoted by the variable Phi here.

% We can only obtain it through the numerical integration of the DE 
% D deltaX = A deltaX, which is implemented in fnTwoBodyAugmented.m

% We now have the nominal trajectory about which we are going to linearize 
% the dynamics. We also have the state transition matrix evaluated at each 
% timestep of the simulation. The state transition matrices will be
% incorporated into the observation model matrices in the next section.

%% Observation Model Matrices

% We have a window which starts after the validity instant (tstart).
tstart = 1; % validity instant. 
% The filtering can only be done after the next data sample is read because
% our filter will estimate two states. [Observability condition]

% FilterWindowLength == L in the book TFE
FilterWindowLength = 36; 
tstop = tstart + 80 -1 ;

% Observation matrix
M = eye(6);

% TotalObservationMatrix == matrix T sans serif in the book 
% T matrix and its transpose
TotalObservationMatrix = zeros(6*FilterWindowLength,6);
TotalObservationMatrixTranspose = zeros(6,FilterWindowLength*6);  % T' sans serif matrix in the book

% Y vector
% TotalObservationVector == matrix Y sans serif in TFE
TotalObservationVector = zeros(6*FilterWindowLength,1);

% delta Y vector == simulated perturbation vector in TFE
delta_Y = zeros(6*FilterWindowLength,1);

% simulated observation vector
Ynom = zeros(6,size(Xnom,2));
Ynom(1:6,:) = Xnom(1:6,:); % Technically, this should be Ynominal = M* Xnominal 

% Initialize the 4 matrices
TotalObservationMatrix(6*tstart-5:6*tstart,:) = M*PhiT(6*tstart-5:6*tstart,1:6); % M is identity matrix here. (We're observing both state variables)
TotalObservationMatrixTranspose(:,6*tstart-5:6*tstart) = M*PhiT(6*tstart-5:6*tstart,1:6); % PhiT, the STM, is equal to identity matrix on initialization. 

% Load the sensor input into the TotalObservationVector at the validity instant Tvi == tstart
TotalObservationVector(6*tstart-5:6*tstart) =  Y(1:6,tstart);

% Load the starting sample into the simulated perturbation vector
delta_Y(6*tstart-5:6*tstart) = Y(1:6,tstart) - Ynom(1:6,tstart);  % Ynom = MXnom, but here M = identity matrix

% We have two estimates: an estimate of the covariance matrix and an
% estimate of the deviation vector.

% delta_X_hat == estimated deviation vector
delta_X_hat = zeros(6*(tstop - tstart + 1),1);

% S_hat == estimated covariance matrix
S_hat = zeros(6*(tstop-tstart + 1),6);

% Best estimate of observation error
varepsilon_hat = zeros(size(Y));
varepsilon_hat(:,1) = Y(:,1) - X(:,1); 

% RMSE 
RMSEvector = zeros(tstop - tstart + 1,1);

% Initialize estimated state vector
X_hat = zeros(size(X));
X_hat(:,tstart) = X(:,tstart);

% Now cycle the filter
for index = tstart+1:tstop
   if index < FilterWindowLength + tstart
        % This section deals with the case when we have fewer sensor
        % samples than the filter length size.
        
        % Load the filter's input stack
        % The T matrix and its transpose
        TotalObservationMatrix(6*(index-tstart+1)-5:6*(index-tstart+1),:) = M*PhiT(6*(index-tstart+1)-5:6*(index-tstart+1),1:6);
        TotalObservationMatrixTranspose(:,6*(index-tstart+1)-5:6*(index-tstart+1)) = (M*PhiT(6*(index-tstart+1)-5:6*(index-tstart+1),1:6))';
        
        % The Y sans serif vector
        TotalObservationVector(6*(index-tstart+1)-5:6*(index-tstart+1)) = Y(:,index-tstart+1);
        
        % Find the simulated perturbation vector, delta_y 
        delta_Y(6*(index-tstart+1)-5:6*(index-tstart+1)) = Y(:,index-tstart+1)' - Ynom(1:6,index-tstart+1)'; 
        
        % Note that in the commands above:
        % 'index - tstart + 1' moves the pointer to the next empty slot in
        % the filter stack
           
        % Initial Covariance matrices
        R = diag([StandardDeviationX;StandardDeviationY;StandardDeviationZ]);
        Rc = repmat({R},index - tstart + 1 ,2);
        Ryn =blkdiag(Rc{:}); % We form the sensor noise covariance matrix
        
        % Note that we have assumed homoskedacity: all sets of observations have
        % the same variance.
        % We have also assumed that there is no time correlation between the
        % observations. That's why the off-diagonal elements are 0.

        RInv = diag([1/StandardDeviationX;1/StandardDeviationY;1/StandardDeviationZ]);
        RcInv = repmat({RInv},index - tstart + 1,2);
        RynInv = blkdiag(RcInv{:}); % The inverse of the sensor noise covariance matrix
        
        % Information matrix
        Lambda = TotalObservationMatrixTranspose(1:6,1:6*index)*RynInv*TotalObservationMatrix(1:6*index,1:6);
        LambdaInv = inv(Lambda);

        % Filter matrix W in TFE == matrix M in Tapley,Schutz,Born.
        W = LambdaInv*TotalObservationMatrixTranspose(1:6,1:6*index)*RynInv;
        
        % Estimated covariance matrix
        S_hat(6*index-5:6*index,:) = LambdaInv;% W*Ryn*W';

        % Estimated perturbation vector
        delta_X_hat(6*index-5:6*index) = W*delta_Y(1:6*index);%TotalObservationVector;
        % The command above is essentially equation 9.9.9 on page 310 of TFE.

        % Estimated state vector
        X_hat(:,index) = delta_X_hat(6*index-5:6*index) + Xnom(1:6,index);


%         fprintf('Comparison of actual and estimated state vector');
%         X(index,:)
%         X_hat
%           
        
    else
        % This section deals when we have more or equal number of sensor
        % samples as the filter window length. 
        
        % Note that in the commands below:
        % After moving the pointer by 'index - tstart + 1', we want to
        % replace the oldest entry in the matrix by the newest sensor data.
        % Then we circularly shift the array to get it into the correct
        % chronological order.
        % Note that the oldest entry in all matrices will always be the
        % entry corresponding to index 1.
        
        % Replace the outdated samples by the new sample.
        % The T matrix
        %TotalObservationMatrix(6*(index-tstart+1)-5:6*(index-tstart+1),:) = M*PhiT(6*(index-tstart+1)-5:6*(index-tstart+1),1:6);
        TotalObservationMatrix(6*1-5:6*1,:) = M*PhiT(6*(index-tstart+1)-5:6*(index-tstart+1),1:6);
        % Reset the matrix
        TotalObservationMatrix = circshift(TotalObservationMatrix, [-6 6]);
        
        % The T matrix transpose
        TotalObservationMatrixTranspose(:,6*1-5:6*1) = (M*PhiT(6*(index-tstart+1)-5:6*(index-tstart+1),1:6))';
        % Reset the matrix
        TotalObservationMatrixTranspose = circshift(TotalObservationMatrixTranspose, [6 -6]);
        
        % The Y sans serif vector
        TotalObservationVector(6*1-5:6) = Y(:,index-tstart+1); % Replace the oldest sample
        TotalObservationVector = circshift(TotalObservationVector, -6); % Reset the vector
        
        % The simulated perturbation vector, delta_y 
        delta_Y(6*1-5:6*1) = Y(:,index-tstart+1)' - Ynom(:,index-tstart+1)'; % Replace the oldest sample 
        delta_Y = circshift(delta_Y,-6); % Reset the vector
        
        % Initial Covariance matrices
        R = diag([StandardDeviationX;StandardDeviationY;StandardDeviationZ]);
        Rc = repmat({R},FilterWindowLength ,2);
        Ryn =blkdiag(Rc{:}); % We form the sensor noise covariance matrix
        
        % Note that we have assumed homoskedacity: all sets of observations have
        % the same variance.
        % We have also assumed that there is no time correlation between the
        % observations. That's why the off-diagonal elements are 0.

        RInv = diag([1/StandardDeviationX;1/StandardDeviationY;1/StandardDeviationZ]);
        RcInv = repmat({RInv},FilterWindowLength,2);
        RynInv = blkdiag(RcInv{:}); % The inverse of the sensor noise covariance matrix
        
        % Information matrix and its inverse
        Lambda = TotalObservationMatrixTranspose*RynInv*TotalObservationMatrix;
        
        LambdaInv = inv(Lambda);
        
        % Filter matrix W in TFE == matrix M in Tapley,Schutz,Born.
        W = LambdaInv*TotalObservationMatrixTranspose*RynInv;
        
        % Estimated covariance matrix
        S_hat(6*index-5:6*index,:)= LambdaInv;% W*Ryn*W';

        % Estimated perturbation vector
        delta_X_hat(6*index-5:6*index) = W*delta_Y;%TotalObservationVector;
        % The command above is essentially equation 9.9.9 on page 310 of TFE.

        % Estimated state vector
        X_hat(:,index) = delta_X_hat(6*index-5:6*index) + Xnom(1:6,index);



%         fprintf('Comparison of actual and estimated state vector');
%         Xactual(index,:)
%         X_hat
%         
    end 
end

clear W Lambda LambdaInv RInv RcInv M

%% Save data
data = 'FilterEstimates.mat';
save(data,'X_hat','S_hat');

%% Explanation
% Our dynamical model of a satellite on the Molniya orbit is nonlinear.
% However our observation model is linear. Therefore we are in Case 3
% according to Tracking Filter Engineering. We also use Version 2 of the
% Minimum Variance Algorithm (MVA). Hence we call this filter GNF(3)2.

%% Note
% More info found in ReadmePjMolniya.txt
